[
    {
        "input": "import argparse\nimport json\nimport os\nimport requests\nimport subprocess\nimport tempfile\n\n# This script integrates the MermaidDiagramGenerator into the main pipeline, generating and validating Mermaid diagrams for each unique response. \n# If a diagram generation fails, it adjusts the temperature and retries until a valid diagram is produced or all attempts are exhausted. \n# Each valid diagram is saved as a PNG in the \"Entries\" folder with a filename reflecting its entry and output number. \n# The script writes to the JSON file after processing each input, ensuring that the data is incrementally saved.\n\n##### MermaidDiagramGenerator Class #####\nclass MermaidDiagramGenerator:\n    def __init__(self, theme='dark', background='transparent'):\n        self._theme = theme\n        self._background = background\n        self._entries_dir = os.path.join(os.getcwd(), 'Entries')\n        os.makedirs(self._entries_dir, exist_ok=True)\n\n    def convert_to_image(self, mermaid_code, entry_number, output_number):\n        clean_code = self._remove_mermaid_block_markers(mermaid_code)\n        output_filename = f\"entry_{entry_number}_{output_number}.png\"\n        output_path = os.path.join(self._entries_dir, output_filename)\n        self._generate_image_from_code(clean_code, output_path)\n        return output_path\n\n    def _remove_mermaid_block_markers(self, code):\n        code_lines = code.strip().splitlines()\n        if code_lines[0].startswith(\"```mermaid\") and code_lines[-1] == \"```\":\n            return \"\\n\".join(code_lines[1:-1]).strip()\n        return code\n\n    def _generate_image_from_code(self, mermaid_code, output_path):\n        with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.mmd') as temp_file:\n            temp_file.write(mermaid_code)\n            input_path = temp_file.name\n        result = subprocess.run([\"mmdc\", \"-i\", input_path, \"-o\", output_path, \"-t\", self._theme, \"-b\", self._background], shell=True, check=False)\n        os.remove(input_path)\n        if result.returncode != 0:\n            raise ValueError(\"Mermaid diagram generation failed.\")\n\n##### Script to Generate Responses and Validate Mermaid Diagrams #####\ndef read_input(input_source):\n    if os.path.isfile(input_source):\n        filename, file_extension = os.path.splitext(input_source)\n        if file_extension == '.json':\n            with open(input_source, 'r') as file:\n                return json.load(file)\n        elif file_extension == '.txt':\n            with open(input_source, 'r') as file:\n                return [{\"input\": file.read()}]\n    else:\n        return [{\"input\": input_source}]\n\ndef generate_unique_responses(prompt, base_temperatures, stream, generator, entry_number):\n    prompt_template = \"\"\"\n    Below is an instruction that describes a task, paired with an input that provides further context.\n    Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Create the mermaid diagram for the following input:\n\n    ### Input:\n    {input}\n\n    ### Response:\n    ```mermaid\n    graph TD;\n\n    \"\"\".format(input=prompt)\n    url = \"http://127.0.0.1:5000/v1/completions\"\n    headers = {\"Content-Type\": \"application/json\"}\n    dataset_entries = []\n    unique_outputs = set()\n\n    for output_number, temp in enumerate(base_temperatures, start=1):\n        while True:\n            data = {\n                \"prompt\": prompt_template,\n                \"max_tokens\": 4096,\n                \"temperature\": temp,\n                \"top_p\": 1.0,\n                \"seed\": -1,\n                \"top_k\": 40,\n                \"repetition_penalty\": 1.0,\n                \"typical_p\": 1.0,\n                \"stream\": stream,\n            }\n\n            response = requests.post(url, headers=headers, json=data, verify=False)\n            response_text = response.json()['choices'][0]['text'].strip()\n\n            # Remove ```mermaid and ``` markers if present\n            if response_text.startswith(\"```mermaid\"):\n                response_text = response_text[len(\"```mermaid\"):].strip()\n            if response_text.endswith(\"```\"):\n                response_text = response_text[:-len(\"```\")].strip()\n\n            # Ensure the Mermaid code starts with 'graph TD;' for both image generation and dataset entry\n            mermaid_code_for_image = \"graph TD;\\n\" + response_text\n            formatted_response_text = \"'''mermaid\\ngraph TD;\\n\" + response_text + \"\\n'''\"\n\n            if mermaid_code_for_image not in unique_outputs:\n                try:\n                    # Convert the Mermaid code to an image\n                    image_path = generator.convert_to_image(mermaid_code_for_image, entry_number, output_number)\n                    print(f\"Mermaid diagram generated at: {image_path}\")\n\n                    unique_outputs.add(mermaid_code_for_image)  # Add the Mermaid code to the set to avoid duplicates\n                    break\n                except ValueError as e:\n                    print(f\"Validation failed, retrying... Error: {e}\")\n                    temp += 0.1  # Adjust temperature and retry if Mermaid diagram is invalid\n            else:\n                temp += 0.1  # Adjust temperature if output is not unique\n\n            dataset_entry = {\n                \"input\": prompt,\n                \"output\": formatted_response_text,  # Use the formatted Mermaid code for the dataset entry\n                \"temperature\": temp\n            }\n            dataset_entries.append(dataset_entry)\n\n    return dataset_entries\n\ndef main(input_source, stream=False):\n    generator = MermaidDiagramGenerator()\n    input_data = read_input(input_source)\n    base_temperatures = [i / 10 for i in range(5, 11)]  # Adjusted for batch of unique outputs per input\n    output_file = \"output.json\"\n    all_entries = []  # Initialize an empty list to store all entries\n\n    for entry_number, entry in enumerate(input_data, start=1):\n        prompt = entry.get(\"input\", \"\")\n        if prompt:\n            entries = generate_unique_responses(prompt, base_temperatures, stream, generator, entry_number)\n            all_entries.extend(entries)  # Extend the list with new entries\n\n    # Write all entries to the JSON file at once\n    with open(output_file, \"w\") as f:\n        json.dump(all_entries, f, indent=4)  # Dump the entire list of entries into the file\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Generate unique responses and validate Mermaid diagrams.\")\n    parser.add_argument('input_source', type=str, help='A multi-line string, path to a .txt file, or a .json file with prompts.')\n    parser.add_argument('--stream', action='store_true', help='Use streaming responses.')\n    args = parser.parse_args()\n    \n    main(args.input_source, args.stream)",
        "output": "graph TD;\n    A[Start Script] --> B[Initialize Classes];\n    B --> C[Read Input Data Source];\n    C --> D{Valid Input File?};\n    D --> |Yes| E[Extend Entry List];\n    D --> |No| F[Exit with Error];\n    E --> G[Generate Unique Responses];\n    G --> H[Convert to Images];\n    H --> I[Add Unique Outputs];\n    I --> J[Write JSON File]; \n    J --> K[End Script];\n    ```",
        "temperature": 0.5
    },
    {
        "input": "import argparse\nimport json\nimport os\nimport requests\nimport subprocess\nimport tempfile\n\n# This script integrates the MermaidDiagramGenerator into the main pipeline, generating and validating Mermaid diagrams for each unique response. \n# If a diagram generation fails, it adjusts the temperature and retries until a valid diagram is produced or all attempts are exhausted. \n# Each valid diagram is saved as a PNG in the \"Entries\" folder with a filename reflecting its entry and output number. \n# The script writes to the JSON file after processing each input, ensuring that the data is incrementally saved.\n\n##### MermaidDiagramGenerator Class #####\nclass MermaidDiagramGenerator:\n    def __init__(self, theme='dark', background='transparent'):\n        self._theme = theme\n        self._background = background\n        self._entries_dir = os.path.join(os.getcwd(), 'Entries')\n        os.makedirs(self._entries_dir, exist_ok=True)\n\n    def convert_to_image(self, mermaid_code, entry_number, output_number):\n        clean_code = self._remove_mermaid_block_markers(mermaid_code)\n        output_filename = f\"entry_{entry_number}_{output_number}.png\"\n        output_path = os.path.join(self._entries_dir, output_filename)\n        self._generate_image_from_code(clean_code, output_path)\n        return output_path\n\n    def _remove_mermaid_block_markers(self, code):\n        code_lines = code.strip().splitlines()\n        if code_lines[0].startswith(\"```mermaid\") and code_lines[-1] == \"```\":\n            return \"\\n\".join(code_lines[1:-1]).strip()\n        return code\n\n    def _generate_image_from_code(self, mermaid_code, output_path):\n        with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.mmd') as temp_file:\n            temp_file.write(mermaid_code)\n            input_path = temp_file.name\n        result = subprocess.run([\"mmdc\", \"-i\", input_path, \"-o\", output_path, \"-t\", self._theme, \"-b\", self._background], shell=True, check=False)\n        os.remove(input_path)\n        if result.returncode != 0:\n            raise ValueError(\"Mermaid diagram generation failed.\")\n\n##### Script to Generate Responses and Validate Mermaid Diagrams #####\ndef read_input(input_source):\n    if os.path.isfile(input_source):\n        filename, file_extension = os.path.splitext(input_source)\n        if file_extension == '.json':\n            with open(input_source, 'r') as file:\n                return json.load(file)\n        elif file_extension == '.txt':\n            with open(input_source, 'r') as file:\n                return [{\"input\": file.read()}]\n    else:\n        return [{\"input\": input_source}]\n\ndef generate_unique_responses(prompt, base_temperatures, stream, generator, entry_number):\n    prompt_template = \"\"\"\n    Below is an instruction that describes a task, paired with an input that provides further context.\n    Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Create the mermaid diagram for the following input:\n\n    ### Input:\n    {input}\n\n    ### Response:\n    ```mermaid\n    graph TD;\n\n    \"\"\".format(input=prompt)\n    url = \"http://127.0.0.1:5000/v1/completions\"\n    headers = {\"Content-Type\": \"application/json\"}\n    dataset_entries = []\n    unique_outputs = set()\n\n    for output_number, temp in enumerate(base_temperatures, start=1):\n        while True:\n            data = {\n                \"prompt\": prompt_template,\n                \"max_tokens\": 4096,\n                \"temperature\": temp,\n                \"top_p\": 1.0,\n                \"seed\": -1,\n                \"top_k\": 40,\n                \"repetition_penalty\": 1.0,\n                \"typical_p\": 1.0,\n                \"stream\": stream,\n            }\n\n            response = requests.post(url, headers=headers, json=data, verify=False)\n            response_text = response.json()['choices'][0]['text'].strip()\n\n            # Remove ```mermaid and ``` markers if present\n            if response_text.startswith(\"```mermaid\"):\n                response_text = response_text[len(\"```mermaid\"):].strip()\n            if response_text.endswith(\"```\"):\n                response_text = response_text[:-len(\"```\")].strip()\n\n            # Ensure the Mermaid code starts with 'graph TD;' for both image generation and dataset entry\n            mermaid_code_for_image = \"graph TD;\\n\" + response_text\n            formatted_response_text = \"'''mermaid\\ngraph TD;\\n\" + response_text + \"\\n'''\"\n\n            if mermaid_code_for_image not in unique_outputs:\n                try:\n                    # Convert the Mermaid code to an image\n                    image_path = generator.convert_to_image(mermaid_code_for_image, entry_number, output_number)\n                    print(f\"Mermaid diagram generated at: {image_path}\")\n\n                    unique_outputs.add(mermaid_code_for_image)  # Add the Mermaid code to the set to avoid duplicates\n                    break\n                except ValueError as e:\n                    print(f\"Validation failed, retrying... Error: {e}\")\n                    temp += 0.1  # Adjust temperature and retry if Mermaid diagram is invalid\n            else:\n                temp += 0.1  # Adjust temperature if output is not unique\n\n            dataset_entry = {\n                \"input\": prompt,\n                \"output\": formatted_response_text,  # Use the formatted Mermaid code for the dataset entry\n                \"temperature\": temp\n            }\n            dataset_entries.append(dataset_entry)\n\n    return dataset_entries\n\ndef main(input_source, stream=False):\n    generator = MermaidDiagramGenerator()\n    input_data = read_input(input_source)\n    base_temperatures = [i / 10 for i in range(5, 11)]  # Adjusted for batch of unique outputs per input\n    output_file = \"output.json\"\n    all_entries = []  # Initialize an empty list to store all entries\n\n    for entry_number, entry in enumerate(input_data, start=1):\n        prompt = entry.get(\"input\", \"\")\n        if prompt:\n            entries = generate_unique_responses(prompt, base_temperatures, stream, generator, entry_number)\n            all_entries.extend(entries)  # Extend the list with new entries\n\n    # Write all entries to the JSON file at once\n    with open(output_file, \"w\") as f:\n        json.dump(all_entries, f, indent=4)  # Dump the entire list of entries into the file\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Generate unique responses and validate Mermaid diagrams.\")\n    parser.add_argument('input_source', type=str, help='A multi-line string, path to a .txt file, or a .json file with prompts.')\n    parser.add_argument('--stream', action='store_true', help='Use streaming responses.')\n    args = parser.parse_args()\n    \n    main(args.input_source, args.stream)",
        "output": "graph TD;\n\n    A[Start Script] --> B[Initialize Classes];\n    B --> C[Read Input Data Source];\n    C --> D{Valid Input File?};\n    D -->|Yes| E[Extend Input Data List];\n    D -->|No| Z[Exit Script];\n\n    E --> F[Start Entry Loop];\n    F --> G{Valid Prompt?};\n    G -->|No| F;\n    G -->|Yes| H[Generate Unique Responses];\n\n    H --> I[Extend All Entries List];\n    I --> J{More Entries?};\n    J -->|Yes| F;\n    J -->|No| K[Write All Entries to JSON File];\n\n    K --> L[End Script];\n    ```",
        "temperature": 0.6
    },
    {
        "input": "import argparse\nimport json\nimport os\nimport requests\nimport subprocess\nimport tempfile\n\n# This script integrates the MermaidDiagramGenerator into the main pipeline, generating and validating Mermaid diagrams for each unique response. \n# If a diagram generation fails, it adjusts the temperature and retries until a valid diagram is produced or all attempts are exhausted. \n# Each valid diagram is saved as a PNG in the \"Entries\" folder with a filename reflecting its entry and output number. \n# The script writes to the JSON file after processing each input, ensuring that the data is incrementally saved.\n\n##### MermaidDiagramGenerator Class #####\nclass MermaidDiagramGenerator:\n    def __init__(self, theme='dark', background='transparent'):\n        self._theme = theme\n        self._background = background\n        self._entries_dir = os.path.join(os.getcwd(), 'Entries')\n        os.makedirs(self._entries_dir, exist_ok=True)\n\n    def convert_to_image(self, mermaid_code, entry_number, output_number):\n        clean_code = self._remove_mermaid_block_markers(mermaid_code)\n        output_filename = f\"entry_{entry_number}_{output_number}.png\"\n        output_path = os.path.join(self._entries_dir, output_filename)\n        self._generate_image_from_code(clean_code, output_path)\n        return output_path\n\n    def _remove_mermaid_block_markers(self, code):\n        code_lines = code.strip().splitlines()\n        if code_lines[0].startswith(\"```mermaid\") and code_lines[-1] == \"```\":\n            return \"\\n\".join(code_lines[1:-1]).strip()\n        return code\n\n    def _generate_image_from_code(self, mermaid_code, output_path):\n        with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.mmd') as temp_file:\n            temp_file.write(mermaid_code)\n            input_path = temp_file.name\n        result = subprocess.run([\"mmdc\", \"-i\", input_path, \"-o\", output_path, \"-t\", self._theme, \"-b\", self._background], shell=True, check=False)\n        os.remove(input_path)\n        if result.returncode != 0:\n            raise ValueError(\"Mermaid diagram generation failed.\")\n\n##### Script to Generate Responses and Validate Mermaid Diagrams #####\ndef read_input(input_source):\n    if os.path.isfile(input_source):\n        filename, file_extension = os.path.splitext(input_source)\n        if file_extension == '.json':\n            with open(input_source, 'r') as file:\n                return json.load(file)\n        elif file_extension == '.txt':\n            with open(input_source, 'r') as file:\n                return [{\"input\": file.read()}]\n    else:\n        return [{\"input\": input_source}]\n\ndef generate_unique_responses(prompt, base_temperatures, stream, generator, entry_number):\n    prompt_template = \"\"\"\n    Below is an instruction that describes a task, paired with an input that provides further context.\n    Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Create the mermaid diagram for the following input:\n\n    ### Input:\n    {input}\n\n    ### Response:\n    ```mermaid\n    graph TD;\n\n    \"\"\".format(input=prompt)\n    url = \"http://127.0.0.1:5000/v1/completions\"\n    headers = {\"Content-Type\": \"application/json\"}\n    dataset_entries = []\n    unique_outputs = set()\n\n    for output_number, temp in enumerate(base_temperatures, start=1):\n        while True:\n            data = {\n                \"prompt\": prompt_template,\n                \"max_tokens\": 4096,\n                \"temperature\": temp,\n                \"top_p\": 1.0,\n                \"seed\": -1,\n                \"top_k\": 40,\n                \"repetition_penalty\": 1.0,\n                \"typical_p\": 1.0,\n                \"stream\": stream,\n            }\n\n            response = requests.post(url, headers=headers, json=data, verify=False)\n            response_text = response.json()['choices'][0]['text'].strip()\n\n            # Remove ```mermaid and ``` markers if present\n            if response_text.startswith(\"```mermaid\"):\n                response_text = response_text[len(\"```mermaid\"):].strip()\n            if response_text.endswith(\"```\"):\n                response_text = response_text[:-len(\"```\")].strip()\n\n            # Ensure the Mermaid code starts with 'graph TD;' for both image generation and dataset entry\n            mermaid_code_for_image = \"graph TD;\\n\" + response_text\n            formatted_response_text = \"'''mermaid\\ngraph TD;\\n\" + response_text + \"\\n'''\"\n\n            if mermaid_code_for_image not in unique_outputs:\n                try:\n                    # Convert the Mermaid code to an image\n                    image_path = generator.convert_to_image(mermaid_code_for_image, entry_number, output_number)\n                    print(f\"Mermaid diagram generated at: {image_path}\")\n\n                    unique_outputs.add(mermaid_code_for_image)  # Add the Mermaid code to the set to avoid duplicates\n                    break\n                except ValueError as e:\n                    print(f\"Validation failed, retrying... Error: {e}\")\n                    temp += 0.1  # Adjust temperature and retry if Mermaid diagram is invalid\n            else:\n                temp += 0.1  # Adjust temperature if output is not unique\n\n            dataset_entry = {\n                \"input\": prompt,\n                \"output\": formatted_response_text,  # Use the formatted Mermaid code for the dataset entry\n                \"temperature\": temp\n            }\n            dataset_entries.append(dataset_entry)\n\n    return dataset_entries\n\ndef main(input_source, stream=False):\n    generator = MermaidDiagramGenerator()\n    input_data = read_input(input_source)\n    base_temperatures = [i / 10 for i in range(5, 11)]  # Adjusted for batch of unique outputs per input\n    output_file = \"output.json\"\n    all_entries = []  # Initialize an empty list to store all entries\n\n    for entry_number, entry in enumerate(input_data, start=1):\n        prompt = entry.get(\"input\", \"\")\n        if prompt:\n            entries = generate_unique_responses(prompt, base_temperatures, stream, generator, entry_number)\n            all_entries.extend(entries)  # Extend the list with new entries\n\n    # Write all entries to the JSON file at once\n    with open(output_file, \"w\") as f:\n        json.dump(all_entries, f, indent=4)  # Dump the entire list of entries into the file\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Generate unique responses and validate Mermaid diagrams.\")\n    parser.add_argument('input_source', type=str, help='A multi-line string, path to a .txt file, or a .json file with prompts.')\n    parser.add_argument('--stream', action='store_true', help='Use streaming responses.')\n    args = parser.parse_args()\n    \n    main(args.input_source, args.stream)",
        "output": "graph TD;\n     A[Start Script] --> B[Initialize Classes];\n     B --> C[Read Input Data Source];\n     C --> D[Loop Through Each Prompt];\n     D --> E[Generate Unique Responses];\n     E --> F[Convert Responses to Images];\n     F --> G[Validate Diagrams];\n     G --> H[Increment Temperature];\n     H --> E;\n     E --> I[Append Dataset Entry];\n     I --> J[Write JSON Output];\n     J --> K[End Script];\n    ```",
        "temperature": 0.7
    },
    {
        "input": "import argparse\nimport json\nimport os\nimport requests\nimport subprocess\nimport tempfile\n\n# This script integrates the MermaidDiagramGenerator into the main pipeline, generating and validating Mermaid diagrams for each unique response. \n# If a diagram generation fails, it adjusts the temperature and retries until a valid diagram is produced or all attempts are exhausted. \n# Each valid diagram is saved as a PNG in the \"Entries\" folder with a filename reflecting its entry and output number. \n# The script writes to the JSON file after processing each input, ensuring that the data is incrementally saved.\n\n##### MermaidDiagramGenerator Class #####\nclass MermaidDiagramGenerator:\n    def __init__(self, theme='dark', background='transparent'):\n        self._theme = theme\n        self._background = background\n        self._entries_dir = os.path.join(os.getcwd(), 'Entries')\n        os.makedirs(self._entries_dir, exist_ok=True)\n\n    def convert_to_image(self, mermaid_code, entry_number, output_number):\n        clean_code = self._remove_mermaid_block_markers(mermaid_code)\n        output_filename = f\"entry_{entry_number}_{output_number}.png\"\n        output_path = os.path.join(self._entries_dir, output_filename)\n        self._generate_image_from_code(clean_code, output_path)\n        return output_path\n\n    def _remove_mermaid_block_markers(self, code):\n        code_lines = code.strip().splitlines()\n        if code_lines[0].startswith(\"```mermaid\") and code_lines[-1] == \"```\":\n            return \"\\n\".join(code_lines[1:-1]).strip()\n        return code\n\n    def _generate_image_from_code(self, mermaid_code, output_path):\n        with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.mmd') as temp_file:\n            temp_file.write(mermaid_code)\n            input_path = temp_file.name\n        result = subprocess.run([\"mmdc\", \"-i\", input_path, \"-o\", output_path, \"-t\", self._theme, \"-b\", self._background], shell=True, check=False)\n        os.remove(input_path)\n        if result.returncode != 0:\n            raise ValueError(\"Mermaid diagram generation failed.\")\n\n##### Script to Generate Responses and Validate Mermaid Diagrams #####\ndef read_input(input_source):\n    if os.path.isfile(input_source):\n        filename, file_extension = os.path.splitext(input_source)\n        if file_extension == '.json':\n            with open(input_source, 'r') as file:\n                return json.load(file)\n        elif file_extension == '.txt':\n            with open(input_source, 'r') as file:\n                return [{\"input\": file.read()}]\n    else:\n        return [{\"input\": input_source}]\n\ndef generate_unique_responses(prompt, base_temperatures, stream, generator, entry_number):\n    prompt_template = \"\"\"\n    Below is an instruction that describes a task, paired with an input that provides further context.\n    Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Create the mermaid diagram for the following input:\n\n    ### Input:\n    {input}\n\n    ### Response:\n    ```mermaid\n    graph TD;\n\n    \"\"\".format(input=prompt)\n    url = \"http://127.0.0.1:5000/v1/completions\"\n    headers = {\"Content-Type\": \"application/json\"}\n    dataset_entries = []\n    unique_outputs = set()\n\n    for output_number, temp in enumerate(base_temperatures, start=1):\n        while True:\n            data = {\n                \"prompt\": prompt_template,\n                \"max_tokens\": 4096,\n                \"temperature\": temp,\n                \"top_p\": 1.0,\n                \"seed\": -1,\n                \"top_k\": 40,\n                \"repetition_penalty\": 1.0,\n                \"typical_p\": 1.0,\n                \"stream\": stream,\n            }\n\n            response = requests.post(url, headers=headers, json=data, verify=False)\n            response_text = response.json()['choices'][0]['text'].strip()\n\n            # Remove ```mermaid and ``` markers if present\n            if response_text.startswith(\"```mermaid\"):\n                response_text = response_text[len(\"```mermaid\"):].strip()\n            if response_text.endswith(\"```\"):\n                response_text = response_text[:-len(\"```\")].strip()\n\n            # Ensure the Mermaid code starts with 'graph TD;' for both image generation and dataset entry\n            mermaid_code_for_image = \"graph TD;\\n\" + response_text\n            formatted_response_text = \"'''mermaid\\ngraph TD;\\n\" + response_text + \"\\n'''\"\n\n            if mermaid_code_for_image not in unique_outputs:\n                try:\n                    # Convert the Mermaid code to an image\n                    image_path = generator.convert_to_image(mermaid_code_for_image, entry_number, output_number)\n                    print(f\"Mermaid diagram generated at: {image_path}\")\n\n                    unique_outputs.add(mermaid_code_for_image)  # Add the Mermaid code to the set to avoid duplicates\n                    break\n                except ValueError as e:\n                    print(f\"Validation failed, retrying... Error: {e}\")\n                    temp += 0.1  # Adjust temperature and retry if Mermaid diagram is invalid\n            else:\n                temp += 0.1  # Adjust temperature if output is not unique\n\n            dataset_entry = {\n                \"input\": prompt,\n                \"output\": formatted_response_text,  # Use the formatted Mermaid code for the dataset entry\n                \"temperature\": temp\n            }\n            dataset_entries.append(dataset_entry)\n\n    return dataset_entries\n\ndef main(input_source, stream=False):\n    generator = MermaidDiagramGenerator()\n    input_data = read_input(input_source)\n    base_temperatures = [i / 10 for i in range(5, 11)]  # Adjusted for batch of unique outputs per input\n    output_file = \"output.json\"\n    all_entries = []  # Initialize an empty list to store all entries\n\n    for entry_number, entry in enumerate(input_data, start=1):\n        prompt = entry.get(\"input\", \"\")\n        if prompt:\n            entries = generate_unique_responses(prompt, base_temperatures, stream, generator, entry_number)\n            all_entries.extend(entries)  # Extend the list with new entries\n\n    # Write all entries to the JSON file at once\n    with open(output_file, \"w\") as f:\n        json.dump(all_entries, f, indent=4)  # Dump the entire list of entries into the file\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Generate unique responses and validate Mermaid diagrams.\")\n    parser.add_argument('input_source', type=str, help='A multi-line string, path to a .txt file, or a .json file with prompts.')\n    parser.add_argument('--stream', action='store_true', help='Use streaming responses.')\n    args = parser.parse_args()\n    \n    main(args.input_source, args.stream)",
        "output": "graph TD;\n    A[Start Script] --> B[Initialize Classes];\n    B --> C[Read Input Data Source];\n    C --> D[For Each Entry];\n    D --> E[Generate Unique Responses];\n    E --> F[Convert To Image If Valid];\n    F --> G[Add To Set];\n    G --> H[Adjust Temperature];\n    H --> I[Formatted Response Dataset Entry];\n    I --> J[Append To List];\n    J --> D;\n    D --> K[Write Output File];\n    K --> L[End Script];\n    \n    subgraph Generate Unique Responses\n        E1[Initialize Loop] --> E2[Post Request For Completion];\n        E2 --> E3[Get Reply Text];\n        E3 --> E4[Remove Mermaid Blockers];\n        E4 --> E5{Valid Diagram?};\n        E5 -->|Yes| E6[Convert To Image];\n        E5 -->|No| E7[Adjust Temperature];\n        E7 --> E1;\n        E6 --> E8[Add To Set];\n        E8 --> E9[Break Loop];\n    end\n    \n    subgraph Formatted Response Dataset Entry\n        I1[Create Dataset Entry];\n        I1 --> I2[Output Format];\n        I2 --> I3[Append To List];\n    end\n```",
        "temperature": 0.8
    },
    {
        "input": "import argparse\nimport json\nimport os\nimport requests\nimport subprocess\nimport tempfile\n\n# This script integrates the MermaidDiagramGenerator into the main pipeline, generating and validating Mermaid diagrams for each unique response. \n# If a diagram generation fails, it adjusts the temperature and retries until a valid diagram is produced or all attempts are exhausted. \n# Each valid diagram is saved as a PNG in the \"Entries\" folder with a filename reflecting its entry and output number. \n# The script writes to the JSON file after processing each input, ensuring that the data is incrementally saved.\n\n##### MermaidDiagramGenerator Class #####\nclass MermaidDiagramGenerator:\n    def __init__(self, theme='dark', background='transparent'):\n        self._theme = theme\n        self._background = background\n        self._entries_dir = os.path.join(os.getcwd(), 'Entries')\n        os.makedirs(self._entries_dir, exist_ok=True)\n\n    def convert_to_image(self, mermaid_code, entry_number, output_number):\n        clean_code = self._remove_mermaid_block_markers(mermaid_code)\n        output_filename = f\"entry_{entry_number}_{output_number}.png\"\n        output_path = os.path.join(self._entries_dir, output_filename)\n        self._generate_image_from_code(clean_code, output_path)\n        return output_path\n\n    def _remove_mermaid_block_markers(self, code):\n        code_lines = code.strip().splitlines()\n        if code_lines[0].startswith(\"```mermaid\") and code_lines[-1] == \"```\":\n            return \"\\n\".join(code_lines[1:-1]).strip()\n        return code\n\n    def _generate_image_from_code(self, mermaid_code, output_path):\n        with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.mmd') as temp_file:\n            temp_file.write(mermaid_code)\n            input_path = temp_file.name\n        result = subprocess.run([\"mmdc\", \"-i\", input_path, \"-o\", output_path, \"-t\", self._theme, \"-b\", self._background], shell=True, check=False)\n        os.remove(input_path)\n        if result.returncode != 0:\n            raise ValueError(\"Mermaid diagram generation failed.\")\n\n##### Script to Generate Responses and Validate Mermaid Diagrams #####\ndef read_input(input_source):\n    if os.path.isfile(input_source):\n        filename, file_extension = os.path.splitext(input_source)\n        if file_extension == '.json':\n            with open(input_source, 'r') as file:\n                return json.load(file)\n        elif file_extension == '.txt':\n            with open(input_source, 'r') as file:\n                return [{\"input\": file.read()}]\n    else:\n        return [{\"input\": input_source}]\n\ndef generate_unique_responses(prompt, base_temperatures, stream, generator, entry_number):\n    prompt_template = \"\"\"\n    Below is an instruction that describes a task, paired with an input that provides further context.\n    Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Create the mermaid diagram for the following input:\n\n    ### Input:\n    {input}\n\n    ### Response:\n    ```mermaid\n    graph TD;\n\n    \"\"\".format(input=prompt)\n    url = \"http://127.0.0.1:5000/v1/completions\"\n    headers = {\"Content-Type\": \"application/json\"}\n    dataset_entries = []\n    unique_outputs = set()\n\n    for output_number, temp in enumerate(base_temperatures, start=1):\n        while True:\n            data = {\n                \"prompt\": prompt_template,\n                \"max_tokens\": 4096,\n                \"temperature\": temp,\n                \"top_p\": 1.0,\n                \"seed\": -1,\n                \"top_k\": 40,\n                \"repetition_penalty\": 1.0,\n                \"typical_p\": 1.0,\n                \"stream\": stream,\n            }\n\n            response = requests.post(url, headers=headers, json=data, verify=False)\n            response_text = response.json()['choices'][0]['text'].strip()\n\n            # Remove ```mermaid and ``` markers if present\n            if response_text.startswith(\"```mermaid\"):\n                response_text = response_text[len(\"```mermaid\"):].strip()\n            if response_text.endswith(\"```\"):\n                response_text = response_text[:-len(\"```\")].strip()\n\n            # Ensure the Mermaid code starts with 'graph TD;' for both image generation and dataset entry\n            mermaid_code_for_image = \"graph TD;\\n\" + response_text\n            formatted_response_text = \"'''mermaid\\ngraph TD;\\n\" + response_text + \"\\n'''\"\n\n            if mermaid_code_for_image not in unique_outputs:\n                try:\n                    # Convert the Mermaid code to an image\n                    image_path = generator.convert_to_image(mermaid_code_for_image, entry_number, output_number)\n                    print(f\"Mermaid diagram generated at: {image_path}\")\n\n                    unique_outputs.add(mermaid_code_for_image)  # Add the Mermaid code to the set to avoid duplicates\n                    break\n                except ValueError as e:\n                    print(f\"Validation failed, retrying... Error: {e}\")\n                    temp += 0.1  # Adjust temperature and retry if Mermaid diagram is invalid\n            else:\n                temp += 0.1  # Adjust temperature if output is not unique\n\n            dataset_entry = {\n                \"input\": prompt,\n                \"output\": formatted_response_text,  # Use the formatted Mermaid code for the dataset entry\n                \"temperature\": temp\n            }\n            dataset_entries.append(dataset_entry)\n\n    return dataset_entries\n\ndef main(input_source, stream=False):\n    generator = MermaidDiagramGenerator()\n    input_data = read_input(input_source)\n    base_temperatures = [i / 10 for i in range(5, 11)]  # Adjusted for batch of unique outputs per input\n    output_file = \"output.json\"\n    all_entries = []  # Initialize an empty list to store all entries\n\n    for entry_number, entry in enumerate(input_data, start=1):\n        prompt = entry.get(\"input\", \"\")\n        if prompt:\n            entries = generate_unique_responses(prompt, base_temperatures, stream, generator, entry_number)\n            all_entries.extend(entries)  # Extend the list with new entries\n\n    # Write all entries to the JSON file at once\n    with open(output_file, \"w\") as f:\n        json.dump(all_entries, f, indent=4)  # Dump the entire list of entries into the file\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Generate unique responses and validate Mermaid diagrams.\")\n    parser.add_argument('input_source', type=str, help='A multi-line string, path to a .txt file, or a .json file with prompts.')\n    parser.add_argument('--stream', action='store_true', help='Use streaming responses.')\n    args = parser.parse_args()\n    \n    main(args.input_source, args.stream)",
        "output": "graph TD;\n    \n    A[Start Script] --> B[Initialize Classes];\n    B --> C[Read Input Data Source];\n    C --> D[For Each Entry];\n    D --> E[Generate Unique Responses];\n    E --> F[Add Unique Outputs];\n    F --> G[Formatted Response Text];\n    G --> H[Convert to Image Path];\n    H --> I[Break Loop];\n    I --> J{Output Unique?};\n    J -->|Yes| K[Add to Set];\n    J -->|No| L[Increment Temperature];\n    L --> C;\n    K --> M[Write All Entries to JSON];\n    M --> N[End Script];\n    \n    ```",
        "temperature": 0.9
    },
    {
        "input": "import argparse\nimport json\nimport os\nimport requests\nimport subprocess\nimport tempfile\n\n# This script integrates the MermaidDiagramGenerator into the main pipeline, generating and validating Mermaid diagrams for each unique response. \n# If a diagram generation fails, it adjusts the temperature and retries until a valid diagram is produced or all attempts are exhausted. \n# Each valid diagram is saved as a PNG in the \"Entries\" folder with a filename reflecting its entry and output number. \n# The script writes to the JSON file after processing each input, ensuring that the data is incrementally saved.\n\n##### MermaidDiagramGenerator Class #####\nclass MermaidDiagramGenerator:\n    def __init__(self, theme='dark', background='transparent'):\n        self._theme = theme\n        self._background = background\n        self._entries_dir = os.path.join(os.getcwd(), 'Entries')\n        os.makedirs(self._entries_dir, exist_ok=True)\n\n    def convert_to_image(self, mermaid_code, entry_number, output_number):\n        clean_code = self._remove_mermaid_block_markers(mermaid_code)\n        output_filename = f\"entry_{entry_number}_{output_number}.png\"\n        output_path = os.path.join(self._entries_dir, output_filename)\n        self._generate_image_from_code(clean_code, output_path)\n        return output_path\n\n    def _remove_mermaid_block_markers(self, code):\n        code_lines = code.strip().splitlines()\n        if code_lines[0].startswith(\"```mermaid\") and code_lines[-1] == \"```\":\n            return \"\\n\".join(code_lines[1:-1]).strip()\n        return code\n\n    def _generate_image_from_code(self, mermaid_code, output_path):\n        with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.mmd') as temp_file:\n            temp_file.write(mermaid_code)\n            input_path = temp_file.name\n        result = subprocess.run([\"mmdc\", \"-i\", input_path, \"-o\", output_path, \"-t\", self._theme, \"-b\", self._background], shell=True, check=False)\n        os.remove(input_path)\n        if result.returncode != 0:\n            raise ValueError(\"Mermaid diagram generation failed.\")\n\n##### Script to Generate Responses and Validate Mermaid Diagrams #####\ndef read_input(input_source):\n    if os.path.isfile(input_source):\n        filename, file_extension = os.path.splitext(input_source)\n        if file_extension == '.json':\n            with open(input_source, 'r') as file:\n                return json.load(file)\n        elif file_extension == '.txt':\n            with open(input_source, 'r') as file:\n                return [{\"input\": file.read()}]\n    else:\n        return [{\"input\": input_source}]\n\ndef generate_unique_responses(prompt, base_temperatures, stream, generator, entry_number):\n    prompt_template = \"\"\"\n    Below is an instruction that describes a task, paired with an input that provides further context.\n    Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Create the mermaid diagram for the following input:\n\n    ### Input:\n    {input}\n\n    ### Response:\n    ```mermaid\n    graph TD;\n\n    \"\"\".format(input=prompt)\n    url = \"http://127.0.0.1:5000/v1/completions\"\n    headers = {\"Content-Type\": \"application/json\"}\n    dataset_entries = []\n    unique_outputs = set()\n\n    for output_number, temp in enumerate(base_temperatures, start=1):\n        while True:\n            data = {\n                \"prompt\": prompt_template,\n                \"max_tokens\": 4096,\n                \"temperature\": temp,\n                \"top_p\": 1.0,\n                \"seed\": -1,\n                \"top_k\": 40,\n                \"repetition_penalty\": 1.0,\n                \"typical_p\": 1.0,\n                \"stream\": stream,\n            }\n\n            response = requests.post(url, headers=headers, json=data, verify=False)\n            response_text = response.json()['choices'][0]['text'].strip()\n\n            # Remove ```mermaid and ``` markers if present\n            if response_text.startswith(\"```mermaid\"):\n                response_text = response_text[len(\"```mermaid\"):].strip()\n            if response_text.endswith(\"```\"):\n                response_text = response_text[:-len(\"```\")].strip()\n\n            # Ensure the Mermaid code starts with 'graph TD;' for both image generation and dataset entry\n            mermaid_code_for_image = \"graph TD;\\n\" + response_text\n            formatted_response_text = \"'''mermaid\\ngraph TD;\\n\" + response_text + \"\\n'''\"\n\n            if mermaid_code_for_image not in unique_outputs:\n                try:\n                    # Convert the Mermaid code to an image\n                    image_path = generator.convert_to_image(mermaid_code_for_image, entry_number, output_number)\n                    print(f\"Mermaid diagram generated at: {image_path}\")\n\n                    unique_outputs.add(mermaid_code_for_image)  # Add the Mermaid code to the set to avoid duplicates\n                    break\n                except ValueError as e:\n                    print(f\"Validation failed, retrying... Error: {e}\")\n                    temp += 0.1  # Adjust temperature and retry if Mermaid diagram is invalid\n            else:\n                temp += 0.1  # Adjust temperature if output is not unique\n\n            dataset_entry = {\n                \"input\": prompt,\n                \"output\": formatted_response_text,  # Use the formatted Mermaid code for the dataset entry\n                \"temperature\": temp\n            }\n            dataset_entries.append(dataset_entry)\n\n    return dataset_entries\n\ndef main(input_source, stream=False):\n    generator = MermaidDiagramGenerator()\n    input_data = read_input(input_source)\n    base_temperatures = [i / 10 for i in range(5, 11)]  # Adjusted for batch of unique outputs per input\n    output_file = \"output.json\"\n    all_entries = []  # Initialize an empty list to store all entries\n\n    for entry_number, entry in enumerate(input_data, start=1):\n        prompt = entry.get(\"input\", \"\")\n        if prompt:\n            entries = generate_unique_responses(prompt, base_temperatures, stream, generator, entry_number)\n            all_entries.extend(entries)  # Extend the list with new entries\n\n    # Write all entries to the JSON file at once\n    with open(output_file, \"w\") as f:\n        json.dump(all_entries, f, indent=4)  # Dump the entire list of entries into the file\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Generate unique responses and validate Mermaid diagrams.\")\n    parser.add_argument('input_source', type=str, help='A multi-line string, path to a .txt file, or a .json file with prompts.')\n    parser.add_argument('--stream', action='store_true', help='Use streaming responses.')\n    args = parser.parse_args()\n    \n    main(args.input_source, args.stream)",
        "output": "graph TD;\n     A[Start Script] --> B[Initialize Classes];\n     B --> C[Read Input Data Source];\n     C --> D[For Each Prompt];\n     D --> E[Generate Unique Responses];\n     E --> F[Convert Responses to Images];\n     F --> G[Validate Diagrams];\n     G --> H{Output Valid?};\n     H -->|Yes| I[Save Valid Diagram];\n     H -->|No| J[Adjust Temperature];\n     J --> E;\n     I --> K[Store Entry Data];\n     D --> L{Prompts Left?};\n     L -->|Yes|D;\n     L -->|No| M[Write Output File];\n     M --> N[End Script];\n    \n    subgraph Generate Unique Responses\n     E --> O[Initialize Loop: Temperature];\n     O --> P[Call API with Prompt and Temp];\n     P --> Q[Get Response Text];\n     Q --> R[Remove Block Markers];\n     R --> S{Output Unique?};\n     S --> |Yes|T[Save Image Path];\n     S --> |No| U[Increment Temperature];\n     T --> O;\n     U --> O;\n     end\n    \n    subgraph Validate Diagrams\n     G --> V[Check if Diagram Invalid];\n     V --> W{Invalid?}; \n     W --> |Yes| X[Adjust Temperature];\n     X --> G;\n     W --> |No| Y[Save Valid Image];\n     Y --> K;\n     end\n    \n    subgraph Store Entry Data\n     K --> Z[Construct Data Entry];\n     Z --> A1[Append Entry to List];\n     A1 --> L;\n     end\n    \n    subgraph Write Output File\n     M --> B1[Write Entries to File];\n     B1 --> N;\n     end\n    ```",
        "temperature": 1.0
    }
]